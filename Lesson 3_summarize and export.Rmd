---
title: "L3 plan"
author: "Geoffrey Millard"
date: "9/13/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Goals
  - Get my data out! (exporting, `write.csv()`, or use an RMarkdown)
  - Explore dates (`lubridate`)
  - Summarize data (`dplyr` from `tidyverse`)
  - Generate custom categories
  - Switch between data frame formats (long v. wide)
  - Linear regression and correlation (`lm()`, `cor()`)
  - Shapiro-Wilks, normality test (personally, I failed this test)
  - ANOVA
  - Tukey Honestly Significant Difference
  Time allowing
  - ANOVA contrasts

## Best Practice

Always start your code by cleaning out your environment.

```{r}
rm(list = ls(all.names = TRUE))
```



## Needed Packages

If we cover everything these are the packages we will need.  I'll introduce them when we start using each package.

```{r}
library(dataRetrieval)
library(tidyverse)
library(tidyselect)
library(lubridate) # Part of tidyverse
library(kableExtra)
library(broom)
# time allowing
library(multcomp)
```

## Where we left off

We were importing actual data from NWIS and cleaning it up for today.

```{r importing}
#USGS and EPA dataset retrieval package
library(dataRetrieval) 
#click on "Packages" tab to see functions available in the dataRetrival package

#these are the USGS sites upstream from Honnedaga Lake, NY that we found in the browser
sites <- c('0134277112', '0134277114')

#detailed location information about the site
# readNWISsite(c('0134277112', '0134277114'))

#whatNWISdata displays the datasets available at each site
available <- whatNWISdata(siteNumber=c('0134277112', '0134277114'))
actual <- readNWISpCode(parameterCd = available$parm_cd) #interpret parameter codes
want <- c('00681', '00945', '50287', '50285') #we want: DOC, DSO4, DHg and DMeHg
data <- readNWISqw(siteNumbers = sites, parameterCd=want) #get the data
codes <- readNWISpCode(parameterCd = unique(data$parm_cd)) #confirms that we got what we wanted, shows UNITS!
View(data)
```


```{r parameter names}
data <- data %>% mutate(Analyte = recode(parm_cd, 
                         '00403'  = 'pH',
                         '00409'  = 'Alkalinity',
                         '00681' = "DOC", 
                         '00945' = "SO4", 
                         '50287' = "Hg", 
                         '50285' = "MeHg"))

data <- data %>% mutate(Site = recode(site_no, 
                         '0134277112' = "Reference", 
                         '0134277114' = "Treated"))
colnames(data)
data1 <- data %>% dplyr::select(Site, Date=sample_dt, Analyte, Result=result_va)

data1$Treatment <- NA
data1$Treatment[ data1$Date < ymd('2013-10-1')  ] <- 1
data1$Treatment[ data1$Date >= ymd('2013-10-1') ] <- 2
data1$Treatment[ data1$Date > ymd('2014-02-28') ] <- 3  # error because I am using the wrong lubridate function
```


## Exporting already?

Maybe this is all you needed to do and now your sharing it with a colleague who is going to do everything else (wouldn't that be lovely!).  If you are working in an Rmarkdown, the html output copies into MS Office applications very nicely, or you can output to a word document.  

If you want something systematic (eg. because your doing this with lots of datasets) the baseR `write.csv` function is pretty useful.  You do need to specify the dataframe and the filename.

```{r}
write.csv(data1, 'Simplified_long_format.csv')
```


## That thing everybody loves: dating

The lubridate package is a huge improvement over managing dates with baseR (eg. baseR months go from 0-11, so don't get tripped up!), because it makes it easier to separate days, months and years.  

First, Lets check and see if our Date data is actually a date.

```{r check data class}
str(data1$Date) # can also use this on the whole data frame, but that can be hard to follow

class(data1$Date)
```
## Look at these: Summary stats

Now that we have cleaned data, we want to take a quick look at it.  The fastest, simplest method is called 'piping' (`%>%`) and is part of the `dplyr` package.  We can use this to generate an overall average for each site, analyte or any other variable with a column in the data frame.

```{r summary table}
Table1 <- data1[data1$Analyte=='DOC',] %>%
  group_by(Site, Analyte, year(Date)) %>% 
  summarize(average=mean(Result), n=n())
Table1
```

This is wonderful, but does not actually look like a publishable table.  `kableExtra` to save the day!

```{r kable summary table}
kable(Table1) %>% 
  kable_styling(bootstrap_options = c('striped', 'hover'), full_width = F)
```


# Exercise break 1

For each site, analyte, and month, generate the mean, standard deviation, maximum and minimum values, and the n-value?


```{r Solution Ex. 1}
Table2 <- data1 %>% 
  group_by(Site, Analyte, month(Date)) %>% 
  summarize(average=mean(Result, na.rm=T), 
            stdv=sd(Result, na.rm=T),
            max=max(Result, na.rm=T), 
            min=min(Result, na.rm=T), 
            n = n())
Table2
Table2 %>% kable() %>% 
kable_styling(bootstrap_options = c('striped', 'hover'), full_width = F)
```

While this is fun, I can think of no application where we would actually want to average a whole dataset.  We might want to include a year, or month?

## That thing everybody loves: dating

The lubridate package is a huge improvement over managing dates with baseR (eg. baseR months go from 0-11, so don't get tripped up!), because it makes it easier to separate days, months and years.  

First, Lets check and see if our Date data is actually a date.



```{r summarize by year and month, results=F}


Table4 <- data1[data1$Analyte=='DOC',] %>%
  group_by(Site, Analyte, month(Date)) %>% 
  summarize(average=mean(Result), n=n())
Table4
```


```{r kable summarize by year and month}
Table4 %>% kable() %>% 
kable_styling(bootstrap_options = c('striped', 'hover', 'bordered'), full_width = F)
```

We want to use dates to separate out the pre-treatment, transitional, and post-treatment time periods in this dataset.  I am most comfortable using baseR syntax for this.

## Excercise Break 2

```{r treatment variable}
data1$Treatment <- NA
data1$Treatment[ data1$Date < ymd('2013-10-1')  ] <- 1
data1$Treatment[ data1$Date >= ymd('2013-10-1') ] <- 2
data1$Treatment[ data1$Date > mdy('2014-02-28') ] <- 3  # error because I am using the wrong lubridate function
```

```{r corrected Treatment variable, echo=F}
data1$Treatment[ data1$Date > ymd('2014-02-28') ] <- 3
```


It would also be nice to set this as a factor or categorical variable.

```{r factor Treatment}
data1$Treatment <- factor(data1$Treatment, levels = c(1, 2, 3), labels = c('Pre-Treatment', 'Transitional', 'Post-Treatment'), ordered = T)
head(data1$Treatment)
```


## Exercise break 3

Can you generate a nice summary table for each analyte in each treatment period? (Time depending)

```{r}
Table5 <- data1 %>% 
  group_by(Treatment, Analyte, Site) %>% 
  summarize(average=mean(Result, na.rm=T), 
            stdv=sd(Result, na.rm=T),
            max=max(Result, na.rm=T), 
            min=min(Result, na.rm=T), 
            n = n())
Table5
Table5 %>% kable() %>% 
kable_styling(bootstrap_options = c('striped', 'hover'), full_width = F)
```

